var Q={INIT:1,PING:2,PONG:3,MESSAGE:4};function V(C,N,q){let G=String(C),z=N,$=q;if(q===void 0&&typeof N!=="string")$=N,z=void 0;if(z)G+=z;if($)G+=JSON.stringify($);return G}function I(C,N){return V(Q.MESSAGE,C,N)}function J(C){if(typeof C==="string");else if(C instanceof ArrayBuffer||ArrayBuffer.isView(C)&&C instanceof DataView===!1)C=D.decode(C);else{const z=new TypeError("Invalid payload type.");throw z.payload=C,z}const N={payload_type:C.codePointAt(0)-48};let q=1,G="";for(let z=q;z<C.length&&x.has(C[z])===!1;z++)G+=C[z],q++;if(G.length>31)throw new Error("Event type cannot be longer than 31 characters.");if(G.length>0)N.event_type=G;if(q<C.length)N.data=JSON.parse(C.slice(q));return N}var x=new Set(["[","{"]),D=new TextDecoder;var K=(C={})=>({emit(N,...q){(C[N]??[]).forEach((G)=>G(...q))},on(N,q){return C[N]=(C[N]??new Set).add(q),()=>C[N].delete(q)},once(N,q,G){return G=this.on(N,(...z)=>{G(),q(...z)})}});var{WebSocket:Z}=self;function h({url:C,headers:N}){if(N)console.warn("Headers are not supported while using WebSocket in browser. They will be ignored.");return new Z(C)}function j(C){return typeof C==="object"&&C!==null&&C.constructor===Object}function F(C){if(C instanceof URL)return C;if(typeof C==="string")return new URL(C);return null}var H=Symbol("extws"),R=new Set([Z.CLOSING,Z.CLOSED]),U={connect:!0,reconnect:!0,reconnect_interval:2000,ping_timeout:5000};class B{#N=K();#C;#H=null;#q=null;#z=null;url;options={};constructor(C){if(j(C))this.url=F(C.url),delete C.url,this.options=Object.freeze(C);else this.url=F(C);if(this.url instanceof URL!==!0)throw new TypeError("Invalid URL.");if(this.#G("connect")===!0)setTimeout(()=>this.connect());this.on("disconnect",()=>{if(this.#C=null,this.#G("reconnect")===!0)clearTimeout(this.#z),this.#z=setTimeout(()=>this.connect(),this.#G("reconnect_interval"))})}#G(C){return this.options[C]??U[C]}get is_connected(){return this.#C&&R.has(this.#C.readyState)!==!0&&Date.now()-this.#C[H].ts_last_message<this.#C[H].idle_timeout}get id(){return this.#C[H].socket_id}#Q(){if(clearTimeout(this.#H),this.#C)this.#H=setTimeout(()=>this.#V(),this.#C[H].idle_timeout-this.#G("ping_timeout"))}#V(){if(clearTimeout(this.#q),this.is_connected)this.#C.send(V(Q.PING)),this.#q=setTimeout(()=>this.disconnect(),this.#G("ping_timeout")*1000)}connect(){if(this.is_connected)return;if(this.#C)this.#C.close();this.#N.emit("beforeconnect");const C=h({url:this.url,headers:this.options.headers});C[H]={socket_id:null,idle_timeout:60000,ts_last_message:0},C.addEventListener("error",(N)=>{console.error(N)}),C.addEventListener("open",()=>{C[H].ts_last_message=Date.now(),this.#Q()}),C.addEventListener("message",(N)=>{clearTimeout(this.#q),this.#Q(),C[H].ts_last_message=Date.now();const{payload_type:q,data:G,event_type:z}=J(N.data);switch(q){case Q.INIT:C[H].socket_id=G.id,C[H].idle_timeout=G.idle_timeout*1000,this.#N.emit("connect");break;case Q.PING:C.send(V(Q.PONG));break;case Q.MESSAGE:this.#N.emit(z??"message",G);break}}),C.addEventListener("close",()=>{C[H].ts_last_message=0,this.#N.emit("disconnect")}),this.#C=C}disconnect(){if(clearTimeout(this.#z),this.#C)this.#C.close()}on(...C){return this.#N.on(...C)}once(...C){return this.#N.once(...C)}send(C,N){if(N===void 0&&typeof C!=="string")N=C,C=void 0;if(this.is_connected)this.#C.send(I(C,N))}}export{B as ExtWSClient};
