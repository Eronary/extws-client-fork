var H={INIT:1,PING:2,PONG:3,MESSAGE:4};function Q(C,N,h){let G=String(C),q=N,Z=h;if(h===void 0&&typeof N!=="string")Z=N,q=void 0;if(q)G+=q;if(Z)G+=JSON.stringify(Z);return G}function I(C,N){return Q(H.MESSAGE,C,N)}function J(C){if(typeof C==="string");else if(C instanceof ArrayBuffer||ArrayBuffer.isView(C)&&C instanceof DataView===!1)C=D.decode(C);else{const q=new TypeError("Invalid payload type.");throw q.payload=C,q}const N={payload_type:C.codePointAt(0)-48};let h=1,G="";for(let q=h;q<C.length&&x.has(C[q])===!1;q++)G+=C[q],h++;if(G.length>31)throw new Error("Event type cannot be longer than 31 characters.");if(G.length>0)N.event_type=G;if(h<C.length)N.data=JSON.parse(C.slice(h));return N}var x=new Set(["[","{"]),D=new TextDecoder;var K=(C={})=>({emit(N,...h){(C[N]??[]).forEach((G)=>G(...h))},on(N,h){return C[N]=(C[N]??new Set).add(h),()=>C[N].delete(h)},once(N,h,G){return G=this.on(N,(...q)=>{G(),h(...q)})}});var{WebSocket:V}=window;function $({url:C,headers:N}){if(N)console.warn("Headers are not supported while using WebSocket in browser. They will be ignored.");return new V(C)}function j(C){return typeof C==="object"&&C!==null&&C.constructor===Object}function F(C){if(C instanceof URL)return C;if(typeof C==="string")return new URL(C);return null}var z=Symbol("extws"),R=new Set([V.CLOSING,V.CLOSED]),U={connect:!0,reconnect:!0,reconnect_interval:2000,ping_timeout:5000};class B{#N=K();#C;#z=null;#h=null;#q=null;url;options={};constructor(C){if(j(C))this.url=F(C.url),delete C.url,this.options=Object.freeze(C);else this.url=F(C);if(this.url instanceof URL!==!0)throw new TypeError("Invalid URL.");if(this.#G("connect")===!0)setTimeout(()=>this.connect());this.on("disconnect",()=>{if(this.#C=null,this.#G("reconnect")===!0)clearTimeout(this.#q),this.#q=setTimeout(()=>this.connect(),this.#G("reconnect_interval"))})}#G(C){return this.options[C]??U[C]}get is_connected(){return this.#C&&R.has(this.#C.readyState)!==!0&&Date.now()-this.#C[z].ts_last_message<this.#C[z].idle_timeout}get id(){return this.#C[z].socket_id}#H(){if(clearTimeout(this.#z),this.#C)this.#z=setTimeout(()=>this.#Q(),this.#C[z].idle_timeout-this.#G("ping_timeout"))}#Q(){if(clearTimeout(this.#h),this.is_connected)this.#C.send(Q(H.PING)),this.#h=setTimeout(()=>this.disconnect(),this.#G("ping_timeout")*1000)}connect(){if(this.is_connected)return;if(this.#C)this.#C.close();this.#N.emit("beforeconnect");const C=$({url:this.url,headers:this.options.headers});C[z]={socket_id:null,idle_timeout:60000,ts_last_message:0},C.addEventListener("error",(N)=>{console.error(N)}),C.addEventListener("open",()=>{C[z].ts_last_message=Date.now(),this.#H()}),C.addEventListener("message",(N)=>{clearTimeout(this.#h),this.#H(),C[z].ts_last_message=Date.now();const{payload_type:h,data:G,event_type:q}=J(N.data);switch(h){case H.INIT:C[z].socket_id=G.id,C[z].idle_timeout=G.idle_timeout*1000,this.#N.emit("connect");break;case H.PING:C.send(Q(H.PONG));break;case H.MESSAGE:this.#N.emit(q??"message",G);break}}),C.addEventListener("close",()=>{C[z].ts_last_message=0,this.#N.emit("disconnect")}),this.#C=C}disconnect(){if(clearTimeout(this.#q),this.#C)this.#C.close()}on(...C){return this.#N.on(...C)}once(...C){return this.#N.once(...C)}send(C,N){if(N===void 0&&typeof C!=="string")N=C,C=void 0;if(this.is_connected)this.#C.send(I(C,N))}}export{B as ExtWSClient};
