var Q={INIT:1,PING:2,PONG:3,MESSAGE:4};function R(C,N,q){let G=String(C),z=N,Z=q;if(q===void 0&&typeof N!=="string")Z=N,z=void 0;if(z)G+=z;if(Z)G+=JSON.stringify(Z);return G}function F(C,N){return R(Q.MESSAGE,C,N)}function I(C){if(typeof C==="string");else if(C instanceof ArrayBuffer||ArrayBuffer.isView(C)&&C instanceof DataView===!1)C=D.decode(C);else{const z=new TypeError("Invalid payload type.");throw z.payload=C,z}const N={payload_type:C.codePointAt(0)-48};let q=1,G="";for(let z=q;z<C.length&&x.has(C[z])===!1;z++)G+=C[z],q++;if(G.length>31)throw new Error("Event type cannot be longer than 31 characters.");if(G.length>0)N.event_type=G;if(q<C.length)N.data=JSON.parse(C.slice(q));return N}var x=new Set(["[","{"]),D=new TextDecoder;var J=(C={})=>({emit(N,...q){(C[N]??[]).forEach((G)=>G(...q))},on(N,q){return C[N]=(C[N]??new Set).add(q),()=>C[N].delete(q)},once(N,q,G){return G=this.on(N,(...z)=>{G(),q(...z)})}});var{WebSocket:V}=self;function $({url:C,headers:N}){if(N)console.warn("[ExtWSClient] Headers are not supported while using WebSocket in browser. They will be ignored.");return new V(C)}function U(C){return typeof C==="object"&&C!==null&&C.constructor===Object}function j(C){if(C instanceof URL)return C;if(typeof C==="string")return new URL(C);return null}var H=Symbol("extws"),K=new Set([V.CLOSING,V.CLOSED]),h={connect:!0,reconnect:!0,reconnect_interval:2000,ping_timeout:5000};class B{#N=J();#C;#H=null;#q=null;#z=null;url;options={};constructor(C,N={}){if(this.url=j(C),this.url instanceof URL!==!0)throw new TypeError("Invalid URL.");if(U(N)!==!0)throw new TypeError("Options must be an Object or not defined at all.");if(this.options=N,this.#G("connect")===!0)setTimeout(()=>this.connect());this.on("disconnect",()=>{if(this.#C=null,this.#G("reconnect")===!0)clearTimeout(this.#z),this.#z=setTimeout(()=>this.connect(),this.#G("reconnect_interval"))})}#G(C){return this.options[C]??h[C]}get is_connected(){return this.#C&&K.has(this.#C.readyState)!==!0&&typeof this.id==="string"&&Date.now()-this.#C[H].ts_last_message<this.#C[H].idle_timeout}get id(){return this.#C[H].socket_id}#Q(){if(clearTimeout(this.#H),this.#C)this.#H=setTimeout(()=>this.#R(),this.#C[H].idle_timeout-this.#G("ping_timeout"))}#R(){if(clearTimeout(this.#q),this.is_connected)this.#C.send(R(Q.PING)),this.#q=setTimeout(()=>this.disconnect(),this.#G("ping_timeout")*1000)}connect(){if(this.is_connected)return;if(this.#C)this.#C.close();this.#N.emit("beforeconnect");const C=$({url:this.url,headers:this.options.headers});C[H]={socket_id:null,idle_timeout:60000,ts_last_message:0},C.addEventListener("error",(N)=>{console.error(N)}),C.addEventListener("open",()=>{C[H].ts_last_message=Date.now(),this.#Q()}),C.addEventListener("message",(N)=>{clearTimeout(this.#q),this.#Q(),C[H].ts_last_message=Date.now();const{payload_type:q,data:G,event_type:z}=I(N.data);switch(q){case Q.INIT:C[H].socket_id=G.id,C[H].idle_timeout=G.idle_timeout*1000,this.#N.emit("connect");break;case Q.PING:C.send(R(Q.PONG));break;case Q.MESSAGE:this.#N.emit(z??"message",G);break}}),C.addEventListener("close",()=>{C[H].ts_last_message=0,this.#N.emit("disconnect")}),this.#C=C}disconnect(){if(clearTimeout(this.#z),this.#C)this.#C.close()}on(...C){return this.#N.on(...C)}once(...C){return this.#N.once(...C)}send(C,N){if(N===void 0&&typeof C!=="string")N=C,C=void 0;if(this.is_connected)this.#C.send(F(C,N))}}export{B as ExtWSClient};
