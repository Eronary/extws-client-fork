var C;(function(E){E[E.ERROR=-1]="ERROR",E[E.INIT=1]="INIT",E[E.PING=2]="PING",E[E.PONG=3]="PONG",E[E.MESSAGE=4]="MESSAGE"})(C||(C={}));function G(E,I,c){let O=String(E),M,N;if(c===void 0&&typeof I!=="string")N=I,M=void 0;else if(typeof I==="string")N=c,M=I;if(M)O+=M;if(N)O+=JSON.stringify(N);return O}function B(E){return E instanceof Int8Array||E instanceof Int16Array||E instanceof Int32Array||E instanceof Uint8Array||E instanceof Uint8ClampedArray||E instanceof Uint16Array||E instanceof Uint32Array||E instanceof Float32Array||E instanceof Float64Array||E instanceof BigInt64Array}function S(E){if(typeof E==="string");else if(E instanceof ArrayBuffer||B(E))E=F.decode(E);else if(Array.isArray(E))E=Buffer.concat(E).toString();else throw new TypeError("Invalid payload type.");const I={payload_type:(E.codePointAt(0)??48)-48};let c=1,O="";for(let M=c;M<E.length&&T.has(E[M])===!1;M++)O+=E[M],c++;if(O.length>31){if(A)console.error(`Event type cannot be longer than 31 characters, received "${O}"`);return{payload_type:C.ERROR}}if(O.length>0)I.event_type=O;if(c<E.length){const M=E.slice(c);try{I.data=JSON.parse(M)}catch{if(A)console.error(`Cannot parse payload "${M}": invalid JSON`);return{payload_type:C.ERROR}}}return I}var A=!0,T=new Set(["[","{"]),F=new TextDecoder;var D;(function(E){E.SOCKET="p.socket",E.GROUP="p.group",E.BROADCAST="p.broadcast"})(D||(D={}));class U extends Event{I;constructor(E,I){super(E);this.data=I}}class R extends EventTarget{listeners=new Set;addListener(E,I,c){this.addEventListener(E,I,c);const O=()=>{this.removeEventListener(E,I,c),this.listeners.delete(O)};return this.listeners.add(O),O}on(E,I){return this.addListener(E,I)}once(E,I){return this.addListener(E,I,{once:!0})}wait(E){return new Promise((I)=>{this.once(E,(c)=>{I(c)})})}emit(E,I){this.dispatchEvent(new U(E,I))}destroy(){for(let E of this.listeners)E();this.listeners.clear()}}function _(E){if(Object.keys(E.headers||{}).length>0)console.warn("[@extws/client] Headers are not supported while using WebSocket in browser. They will be ignored.");return new WebSocket(E.url)}var x=WebSocket;function h(E){return typeof E==="object"&&E!==null&&!Array.isArray(E)&&E.constructor===Object}var L=new Set([x.CLOSING,x.CLOSED]);class P extends R{websocket=null;websocket_state=null;url;headers={};options={connect:!0,reconnect:!0,reconnect_interval:2000,ping_timeout:5000};timeouts={};constructor(E,I){super();if(this.url=E,I)this.options={...this.options,...I};if(this.options.connect===!0)setTimeout(()=>this.connect());this.on("disconnect",()=>{if(this.websocket=null,this.websocket_state=null,this.options.reconnect===!0)clearTimeout(this.timeouts.reconnect),this.timeouts.reconnect=setTimeout(()=>this.connect(),this.options.reconnect_interval)})}get is_connected(){return this.websocket!==null&&L.has(this.websocket.readyState)!==!0&&typeof this.id==="string"&&Date.now()-this.websocket_state.ts_last_message<this.websocket_state.idle_timeout}get id(){return this.websocket_state?.socket_id??null}createPing(){if(clearTimeout(this.timeouts.ping),this.websocket)this.timeouts.ping=setTimeout(()=>this.sendPing(),this.websocket_state.idle_timeout-this.options.ping_timeout)}sendPing(){if(clearTimeout(this.timeouts.dead),this.is_connected)this.websocket?.send(G(C.PING)),this.timeouts.dead=setTimeout(()=>this.disconnect(),this.options.ping_timeout*1000)}connect(){if(this.is_connected)return;if(this.websocket)this.websocket.close();this.emit("beforeconnect");const E=_({url:this.url,headers:this.headers});this.websocket=E,this.websocket_state={socket_id:null,idle_timeout:60000,ts_last_message:0},E.addEventListener("error",(I)=>{console.error(I)}),E.addEventListener("open",()=>{if(E===this.websocket)this.websocket_state.ts_last_message=Date.now(),this.createPing()}),E.addEventListener("message",(I)=>{if(E!==this.websocket)return;clearTimeout(this.timeouts.dead),this.createPing(),this.websocket_state.ts_last_message=Date.now();const{payload_type:c,data:O,event_type:M}=S(I.data);switch(c){case C.INIT:if(!h(O)||typeof O.id!=="string"||typeof O.idle_timeout!=="number")throw new TypeError("Invalid data received.");this.websocket_state.socket_id=O.id,this.websocket_state.idle_timeout=O.idle_timeout*1000,this.emit("connect");break;case C.PING:E.send(G(C.PONG));break;case C.MESSAGE:this.emit(M??"message",O);break}}),E.addEventListener("close",()=>{if(E===this.websocket)this.websocket_state.ts_last_message=0,this.emit("disconnect")})}disconnect(){clearTimeout(this.timeouts.reconnect),this.websocket?.close()}send(E,I){if(this.is_connected)this.websocket?.send(G(C.MESSAGE,E,I))}}export{P as ExtWSClient,L as BROKEN_STATES};
